//=============================================================================
//
//  Copyright 2011 (c) Engine Nine. All Rights Reserved.
//
//=============================================================================
fragment SplatterTexture;

[parameters]
float2 SplatterTextureScale = 1;
float4 Mask = 1;

float3 DiffuseColorX = 1;
float3 DiffuseColorY = 1;
float3 DiffuseColorZ = 1;
float3 DiffuseColorW = 1;

float3 SpecularColorX;
float3 SpecularColorY;
float3 SpecularColorZ;
float3 SpecularColorW;

float SpecularPowerX = 16;
float SpecularPowerY = 16;
float SpecularPowerZ = 16;
float SpecularPowerW = 16;

texture2D SplatterTexture;
sampler SplatterTextureSampler = sampler_state
{
    Texture = (SplatterTexture);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
};

texture2D TextureX;
sampler TextureXSampler = sampler_state
{
    Texture = (TextureX);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureY;
sampler TextureYSampler = sampler_state
{
    Texture = (TextureY);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureZ;
sampler TextureZSampler = sampler_state
{
    Texture = (TextureZ);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureW;
sampler TextureWSampler = sampler_state
{
    Texture = (TextureW);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};


texture2D NormalMapX;
sampler NormalMapXSampler = sampler_state
{
    Texture = (NormalMapX);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D NormalMapY;
sampler NormalMapYSampler = sampler_state
{
    Texture = (NormalMapY);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D NormalMapZ;
sampler NormalMapZSampler = sampler_state
{
    Texture = (NormalMapZ);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D NormalMapW;
sampler NormalMapWSampler = sampler_state
{
    Texture = (NormalMapW);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};


[vertex]
float3 Binormal	: BINORMAL0;
float3 Tangent	: TANGENT0;

[interpolators]
float3 Tangent;
float3 Binormal;

[vs]
__hlsl__
void main(INPUT input, inout OUTPUT output)
{
	float3 tangent = input.Tangent;
	float3 binormal = input.Binormal;
    
    float4x3 worldTransform;
	import(WorldTransform, worldTransform = WorldTransform);

    tangent = mul(tangent, worldTransform);
    binormal = mul(binormal, worldTransform);

	output(Tangent, tangent);
	output(Binormal, binormal);
}
__hlsl__


[ps]
__hlsl__
void main(INPUT input, inout OUTPUT output)
{
	float2 uv;
	import(TexCoord, uv = TexCoord);

	float4 color;
	float3 specularColor;
    float  specularPower;
	import(Color, color = Color);    
	import(SpecularColor, specularColor = SpecularColor);
	import(SpecularPower, specularPower = SpecularPower);
	
	float4 splatter = Mask * tex2D(SplatterTextureSampler, uv / SplatterTextureScale);
		
    float3 diffuse = 0;
	{$HASX}diffuse += tex2D(TextureXSampler, uv) * DiffuseColorX * splatter.x;
    {$HASY}diffuse += tex2D(TextureYSampler, uv) * DiffuseColorY * splatter.y;
    {$HASZ}diffuse += tex2D(TextureZSampler, uv) * DiffuseColorZ * splatter.z;
    {$HASW}diffuse += tex2D(TextureWSampler, uv) * DiffuseColorW * splatter.w;
    {$HASDIFFUSE}color.xyz *= diffuse;

    float3 specular = 0;
	{$HASSPECULARX}{$HASX}specular += SpecularColorX * splatter.x;
    {$HASSPECULARY}{$HASY}specular += SpecularColorY * splatter.y;
    {$HASSPECULARZ}{$HASZ}specular += SpecularColorZ * splatter.z;
    {$HASSPECULARW}{$HASW}specular += SpecularColorW * splatter.w;
    specularColor *= specular;
    
    specularPower = 0;
	{$HASSPECULARX}{$HASX}specularPower += SpecularPowerX * splatter.x;
    {$HASSPECULARY}{$HASY}specularPower += SpecularPowerY * splatter.y;
    {$HASSPECULARZ}{$HASZ}specularPower += SpecularPowerZ * splatter.z;
    {$HASSPECULARW}{$HASW}specularPower += SpecularPowerW * splatter.w;
    
	float3 normal;
	import(Normal, normal = Normal);

	float3x3 tangentTransform;
	tangentTransform[0] = input.Tangent;
	tangentTransform[1] = input.Binormal;
	tangentTransform[2] = normal;

    float3 normalFromMap = 0;
    {$HASNORMALX}normalFromMap += (tex2D(NormalMapXSampler, uv).xyz * 2 - 1) * splatter.x;
    {$HASNORMALY}normalFromMap += (tex2D(NormalMapYSampler, uv).xyz * 2 - 1) * splatter.y;
    {$HASNORMALZ}normalFromMap += (tex2D(NormalMapZSampler, uv).xyz * 2 - 1) * splatter.z;
    {$HASNORMALW}normalFromMap += (tex2D(NormalMapWSampler, uv).xyz * 2 - 1) * splatter.w;

    normalFromMap = mul(normalFromMap, tangentTransform);
    normalFromMap = normalize(lerp(normal, normalFromMap, length(normalFromMap)));
	
	export(float3, Normal, normalFromMap);
	export(float3, SpecularColor, specularColor);
	export(float, SpecularPower, specularPower);
	export(float4, Color, color);
}
__hlsl__