//=============================================================================
//
//  Copyright 2010 (c) Engine Nine. All Rights Reserved.
//
//=============================================================================
fragment SplatterTexture;

[parameters]
float2 SplatterTextureScale = 1;
float4 Mask = 1;

texture2D SplatterTexture;
sampler SplatterTextureSampler = sampler_state
{
    Texture = (SplatterTexture);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
};

texture2D TextureX;
sampler TextureXSampler = sampler_state
{
    Texture = (TextureX);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureY;
sampler TextureYSampler = sampler_state
{
    Texture = (TextureY);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureZ;
sampler TextureZSampler = sampler_state
{
    Texture = (TextureZ);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

texture2D TextureW;
sampler TextureWSampler = sampler_state
{
    Texture = (TextureW);
    MipFilter = Linear;
    MagFilter = Linear;
    MinFilter = Linear;
    AddressU = Wrap;
    AddressV = Wrap;
};

[ps]
__hlsl__
void main(INPUT input, inout OUTPUT output)
{
	float2 uv;
	import(TexCoord, uv = TexCoord);

	float4 color;
	import(Color, color = Color);
	
	float4 splatter = Mask * tex2D(SplatterTextureSampler, uv / SplatterTextureScale);
		
    float4 diffuse = 0;
	{$HASX}diffuse += tex2D(TextureXSampler, uv) * splatter.x;
    {$HASY}diffuse += tex2D(TextureYSampler, uv) * splatter.y;
    {$HASZ}diffuse += tex2D(TextureZSampler, uv) * splatter.z;
    {$HASW}diffuse += tex2D(TextureWSampler, uv) * splatter.w;
    color *= diffuse;

	export(float4, Color, color);
}
__hlsl__