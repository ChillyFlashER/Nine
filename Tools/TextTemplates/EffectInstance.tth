<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
// -----------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a text template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// -----------------------------------------------------------------------------
<#@ include file="Content.tth" #>
<#@ include file="Document.tth" #>
#if !TEXT_TEMPLATE
<#
    var assembly = Assembly.LoadFrom(Host.ResolvePath(assemblyFile));
    var assemblyDoc = OpenAssemblyXmlDocument(Host.ResolvePath(assemblyDocumentFile));

    foreach (var namespaceGroup in FindEffectInstanceTypes(assembly).GroupBy(t => t.Namespace.IndexOf("Microsoft") >= 0 ? "Nine.Graphics" : t.Namespace)
                                                                    .OrderBy(g => g.Key))
    {
#>
namespace <#= namespaceGroup.Key #>
{
<#
    foreach (var type in namespaceGroup.OrderBy(t => GetClassName(t)))
    {
        var className = GetClassName(type) + "Instance";
        var classConstructorName = className;
        var members = FindContentSerializableMembers(type).Where(m =>
                            !(m.Name == "World" || m.Name == "View" || m.Name == "Projection" || m.Name == "Name"))
                                                          .OrderBy(m => m.Name).ToArray();
        var implementedInterfaces = type.GetInterfaces().Where(i => i.IsPublic && i.Name != "IEffectMatrices" && i.Name != "IEffectLights" 
                                                                               && i.Name != "IDisposable" && i.Name != "IUpdateable"
                                                                               && i.Name != "IDeferredLight")
                                                        .Select(i => GetClassFullName(i)).ToArray();
        var implementedInterfaceNames = implementedInterfaces.Length > 0 ? ", " + string.Join(", ", implementedInterfaces) : "";
        
        var notSupportedByWindowsPhone = !className.StartsWith("BasicEffect")
                                      && !className.StartsWith("DualTextureEffect")
                                      && !className.StartsWith("SkinnedEffect")
                                      && !className.StartsWith("EnvironmentMapEffect")
                                      && !className.StartsWith("AlphaTestEffect");
        if (notSupportedByWindowsPhone)
        {
#>
#if !WINDOWS_PHONE
<#
        }
#>
    /// <summary>
    /// Effect instance for <c><#= type.Name #></c>.
    /// </summary>
    [Nine.ContentSerializable()]
    [System.CodeDom.Compiler.GeneratedCode("EffectInstance.tt", "1.0.0.0")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.Runtime.CompilerServices.CompilerGenerated()]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public partial class <#= className #> : Nine.Graphics.IEffectInstance
    {        
        /// <summary>
        /// Gets the underlying <#= className #>.
        /// </summary>
        public Microsoft.Xna.Framework.Graphics.Effect Effect { get { return effect; } }
        <#= GetClassFullName(type) #> effect;
		uint dirtyFlag = 0;
<#
    var dirtyFlagIndex = -1;

    foreach (var member in members)
    {
        dirtyFlagIndex++;
        var memberTypeName = GetMemberTypeName(member);
#>
        /// <summary>
        /// <#= GetSummary(assemblyDoc, member.Name).Replace("Gets or sets", "Gets").Replace("Gets", "Gets or sets") #>
        /// </summary>
        public <#= memberTypeName #> <#= member.Name #> 
        { 
            get { return _<#= member.Name #>; }
            set { _<#= member.Name #> = value; dirtyFlag |= <#= member.Name #>DirtyFlag; }
        }
        private <#= memberTypeName #> _<#= member.Name #>;
        const uint <#= member.Name #>DirtyFlag = 1 << <#= dirtyFlagIndex #>;
        static <#= className #> <#= member.Name #>LastModifiedBy = null;
<#
    }
#>

        private <#= classConstructorName #>() { }

        /// <summary>
        /// Initializes a new instance of <c><#= classConstructorName #></c>.
        /// </summary>
        public <#= classConstructorName #>(Microsoft.Xna.Framework.Graphics.GraphicsDevice graphics)
            : this(Nine.Graphics.GraphicsResources<<#= GetClassFullName(type) #>>.GetInstance(graphics))
        {
            
        }

        /// <summary>
        /// Initializes a new instance of <c><#= classConstructorName #></c>.
        /// </summary>
        public <#= classConstructorName #>(<#= GetClassFullName(type) #> effect)
        {
            this.effect = effect;
<#
    foreach (var member in members)
    {
        var memberType = GetMemberType(member);
        var memberTypeName = GetMemberTypeName(member);
#>
            this._<#= member.Name #> = effect.<#= member.Name #>;
<#
    }
#>
        }
        
        /// <summary>
        /// Applys the parameter values to the underlying <#= className #>.
        /// </summary>
        public void Apply()
        {
<#
    foreach (var member in members)
    {
        var memberType = GetMemberType(member);
        var memberTypeName = GetMemberTypeName(member);
#>
            if ((this.dirtyFlag & <#= member.Name #>DirtyFlag) != 0 ||
                (<#= member.Name #>LastModifiedBy != null && <#= member.Name #>LastModifiedBy != this))
            {
                this.effect.<#= member.Name #> = this.<#= member.Name #>;
                <#= member.Name #>LastModifiedBy = this;
            }
<#
    }
#>
            this.dirtyFlag = 0;
        }
        
        /// <summary>
        /// Clones the parameter values to a new instance of <#= className #>.
        /// </summary>
        public IEffectInstance Clone()
        {
            var cloned = new <#= className #>();
            cloned.effect = this.effect;
<#
    foreach (var member in members)
    {
#>
            cloned._<#= member.Name #> = this._<#= member.Name #>;
<#
    }
#>
            return cloned;
        }
    }
<#
        if (notSupportedByWindowsPhone)
        {
#>
#endif
<#
        }
    }
#>
}
<#
    }
#>
#endif