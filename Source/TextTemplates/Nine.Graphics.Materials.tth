<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)..\MGP\MonoGame.Framework.dll" #>
<#@ assembly name="$(SolutionDir)..\MGP\MonoGame.Framework.Content.Pipeline.dll" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="Microsoft.Xna.Framework.Content.Pipeline" #>
<#@ import namespace="Microsoft.Xna.Framework.Content.Pipeline.Graphics" #>
<#@ import namespace="Microsoft.Xna.Framework.Content.Pipeline.Processors" #>
<#@ import namespace="Microsoft.Xna.Framework.Graphics" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Windows.Forms" #>
// -----------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a text template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// -----------------------------------------------------------------------------

#if !TEXT_TEMPLATE
namespace Nine.Graphics.Materials
{
#if !WINDOWS_PHONE

    using System;
    using Microsoft.Xna.Framework;
    using Microsoft.Xna.Framework.Graphics;

<#
    foreach (var fxFile in Directory.GetFiles(Host.ResolvePath(shaderFolder), "*.fx", SearchOption.AllDirectories))
    {
        var className = Path.GetFileNameWithoutExtension(fxFile);
        if (className.EndsWith("Effect"))
            className = className.Replace("Effect", "");
        if (!className.EndsWith("Shader"))
            className = className + "Shader";
        var materialName = className.Replace("Shader", "Material");
        var compiler = new EffectCompiler();
        compiler.Build(fxFile);
#>
    [Nine.Serialization.NotBinarySerializable]
    partial class <#= materialName #> : Material
    {
        public GraphicsDevice GraphicsDevice { get; private set; }

        internal <#= className #> effect;

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= materialName #>"/> class.
        /// </summary>
        public <#= materialName #>(GraphicsDevice graphics)
        {
            GraphicsDevice = graphics;
            effect = GraphicsResources<<#= className #>>.GetInstance(graphics, typeof(<#= materialName #>));

            OnCreated();
        }

        protected override void OnBeginApply(Nine.Graphics.DrawingContext context, Nine.Graphics.Materials.Material previousMaterial)
        {
            <#= materialName #> previous = previousMaterial as <#= materialName #>;
            if (previous == null)
                ApplyGlobalParameters(context);
            BeginApplyLocalParameters(context, previous);
            effect.CurrentTechnique.Passes[0].Apply();
        }

        protected override void OnEndApply(Nine.Graphics.DrawingContext context)
        {
            EndApplyLocalParameters(context);
        }
                
        partial void OnCreated();
        partial void ApplyGlobalParameters(Nine.Graphics.DrawingContext context);
        partial void BeginApplyLocalParameters(Nine.Graphics.DrawingContext context, <#= materialName #> previousMaterial);
        partial void EndApplyLocalParameters(Nine.Graphics.DrawingContext context);
    }
    
    [System.CodeDom.Compiler.GeneratedCode("Nine.Graphics.Materials.tt", "1.0.0.0")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.Runtime.CompilerServices.CompilerGenerated()]
    partial class <#= className #> : Effect
    {
        public <#= className #>(GraphicsDevice graphics) 
            : base(graphics, ReachEffectCode)
        {
<#
        if (compiler.HiDef)
        {
#>
            if (GraphicsDevice.GraphicsProfile != GraphicsProfile.HiDef)
                throw new InvalidOperationException("<#= className #> requires GraphicsProfile.HiDef.");
<#
        }
        foreach (var parameter in compiler.EffectParameters)
        {
#>
            <#= parameter.Name #> = Parameters["<#= parameter.Name #>"];
<#
        }
#>

            OnCreated();
        }

        partial void OnCreated();

<#
        foreach (var parameter in compiler.EffectParameters)
        {
#>
        internal EffectParameter <#= parameter.Name #>;
<#
        }
#>

        #region ByteCode
        internal static byte[] ReachEffectCode = null;
        internal static byte[] HiDefEffectCode = null;

        static <#= className #>()
        {
#if DirectX
            ReachEffectCode = HiDefEffectCode = new byte[] 
            {
<#= compiler.DirectXEffectCode #>
            };
#else
            ReachEffectCode = HiDefEffectCode = new byte[] 
            {
<#= compiler.OpenGLEffectCode #>
            };

#endif
        }
        #endregion
    }
<#
    }
#>
#endif
}
#endif
<#+
    class EffectCompiler : IEqualityComparer<EffectParameter>
    {
        public bool HiDef = false;
        public string DirectXEffectCode;
        public string OpenGLEffectCode;
        public List<EffectParameter> EffectParameters;

        public void Build(string sourceFile)
        {
            // Create graphics device
            Form dummy = new Form();

            PresentationParameters parameters = new PresentationParameters();
            parameters.BackBufferWidth = 1;
            parameters.BackBufferHeight = 1;
            parameters.DeviceWindowHandle = dummy.Handle;

            //GraphicsAdapter.UseNullDevice = true;
            GraphicsDevice device = new GraphicsDevice(GraphicsAdapter.DefaultAdapter, GraphicsProfile.HiDef, parameters);
            
            // MonoGame only has 2 different types of formats in the pipeline.
            CompiledEffectContent directxCompiledEffect = null;
            CompiledEffectContent openglCompiledEffect = null;

            byte[] directxEffectCode = null;
            byte[] openglEffectCode = null;

            try
            {
                HiDef = false;
                directxCompiledEffect = BuildEffect(sourceFile, TargetPlatform.Windows, GraphicsProfile.Reach);
                openglCompiledEffect = BuildEffect(sourceFile, TargetPlatform.WindowsGL, GraphicsProfile.Reach);
            }
            catch
            {
                if (!HiDef)
                {
                    HiDef = true;
                    directxCompiledEffect = BuildEffect(sourceFile, TargetPlatform.Windows, GraphicsProfile.HiDef);
                    openglCompiledEffect = BuildEffect(sourceFile, TargetPlatform.WindowsGL, GraphicsProfile.HiDef);
                }
            }


            directxEffectCode = directxCompiledEffect.GetEffectCode();
            openglEffectCode = openglCompiledEffect.GetEffectCode();

            DirectXEffectCode = ByteArrayToString(directxEffectCode);
            OpenGLEffectCode = ByteArrayToString(openglEffectCode);

            // Initialize parameters
            Effect effect = new Effect(device, directxEffectCode);
            EffectParameters = effect.Parameters.Distinct(this).Where(p => p.ParameterClass != EffectParameterClass.Struct).ToList();
        }

        private CompiledEffectContent BuildEffect(string sourceFile, TargetPlatform targetPlatform, GraphicsProfile targetProfile)
        {
            ContentBuildLogger logger = new CustomLogger();

            // Import the effect source code.
            EffectImporter importer = new EffectImporter();
            ContentImporterContext importerContext = new CustomImporterContext(logger);
            EffectContent sourceEffect = importer.Import(sourceFile, importerContext);
            
            // Compile the effect.
            EffectProcessor processor = new EffectProcessor();
            processor.DebugMode = EffectProcessorDebugMode.Optimize;
            processor.Defines = targetProfile == GraphicsProfile.Reach ? "Reach;REACH;" : "HiDef;HIDEF;";
            processor.Defines += targetPlatform == TargetPlatform.Windows ? "DirectX;" : "OpenGL;";
            ContentProcessorContext processorContext = new CustomProcessorContext(targetPlatform, targetProfile, logger);
            return processor.Process(sourceEffect, processorContext);
        }

        private static string ByteArrayToString(byte[] effectCode)
        {
            if (effectCode == null)
                return "";

            StringBuilder builder = new StringBuilder(effectCode.Length);

            for (int i = 0; i < effectCode.Length; i++)
            {
                if (i > 0 && i % 24 == 0)
                    builder.AppendLine();

                builder.AppendFormat("0x{0:X2}, ", effectCode[i]);
            }

            return builder.ToString();
        }

        public bool Equals(EffectParameter x, EffectParameter y)
        {
            return EffectParameterEquals(x, y);
        }

        bool EffectParameterEquals(EffectParameter a, EffectParameter b)
        {
            return a != null && b != null && a.Name == b.Name;
        }

        public int GetHashCode(EffectParameter obj)
        {
            return 0;
        }
    }

    class CustomImporterContext : ContentImporterContext
    {
        public CustomImporterContext(ContentBuildLogger logger)
        {
            this.logger = logger;
        }

        public override ContentBuildLogger Logger
        {
            get { return logger; }
        }
        ContentBuildLogger logger;

        public override string IntermediateDirectory
        {
            get { return string.Empty; }
        }

        public override string OutputDirectory
        {
            get { return string.Empty; }
        }

        public override void AddDependency(string filename)
        {

        }
    }

    class CustomLogger : ContentBuildLogger
    {
        public CustomLogger()
        {

        }

        public override void LogMessage(string message, params object[] messageArgs)
        {
            System.Diagnostics.Debug.WriteLine(string.Format(message, messageArgs));
        }

        public override void LogImportantMessage(string message, params object[] messageArgs)
        {
            System.Diagnostics.Debug.WriteLine(string.Format(message, messageArgs));
        }

        public override void LogWarning(string helpLink, ContentIdentity contentIdentity, string message, params object[] messageArgs)
        {

        }
    }

    class CustomProcessorContext : ContentProcessorContext
    {
        public CustomProcessorContext(TargetPlatform targetPlatform, GraphicsProfile targetProfile, ContentBuildLogger logger)
        {
            this.targetPlatform = targetPlatform;
            this.targetProfile = targetProfile;
            this.logger = logger;
        }

        public override TargetPlatform TargetPlatform
        {
            get { return targetPlatform; }
        }
        TargetPlatform targetPlatform;

        public override GraphicsProfile TargetProfile
        {
            get { return targetProfile; }
        }

        GraphicsProfile targetProfile;

        public override ContentBuildLogger Logger
        {
            get { return logger; }
        }

        ContentBuildLogger logger;

        public override string BuildConfiguration
        {
            get { return string.Empty; }
        }

        public override string IntermediateDirectory
        {
            get { return string.Empty; }
        }

        public override string OutputDirectory
        {
            get { return string.Empty; }
        }

        public override string OutputFilename
        {
            get { return string.Empty; }
        }

        public override OpaqueDataDictionary Parameters
        {
            get { return parameters; }
        }
        OpaqueDataDictionary parameters = new OpaqueDataDictionary();

        public override void AddDependency(string filename)
        {

        }

        public override void AddOutputFile(string filename)
        {

        }

        public override TOutput Convert<TInput, TOutput>(TInput input, string processorName, OpaqueDataDictionary processorParameters)
        {
            throw new NotImplementedException();
        }

        public override TOutput BuildAndLoadAsset<TInput, TOutput>(ExternalReference<TInput> sourceAsset, string processorName, OpaqueDataDictionary processorParameters, string importerName)
        {
            throw new NotImplementedException();
        }

        public override ExternalReference<TOutput> BuildAsset<TInput, TOutput>(ExternalReference<TInput> sourceAsset, string processorName, OpaqueDataDictionary processorParameters, string importerName, string fileName)
        {
            throw new NotImplementedException();
        }
    }
#>