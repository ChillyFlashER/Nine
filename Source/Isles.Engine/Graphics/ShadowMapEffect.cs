//-----------------------------------------------------------------------------
//  Isles v1.0
//  
//  Copyright 2008 (c) Nightin Games. All Rights Reserved.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Isles.Engine;

namespace Isles.Graphics
{
    /// <summary>
    /// Use shadow mapping technique to generate shadows
    /// </summary>
    public class ShadowMapEffect : IDisposable
    {
        #region Variables & Properties

        Matrix view;
        // Using directional lights is a better way to create precise shadows
        // for this game, since it's in the vast outdoor environment.
        Matrix projection = Matrix.CreateScale(0.5f, 0.5f, -0.01f);
        //Matrix projection = Matrix.CreatePerspectiveFieldOfView(
        //MathHelper.PiOver2, 1.0f, 1.0f, 1000.0f);
        Matrix viewProjection;
        BaseGame game;
        GraphicsDevice graphics;
        DepthStencilBuffer depthStencil;
        DepthStencilBuffer storedDepthStencil;
        RenderTarget2D renderTarget;
        Texture2D shadowMap;
        Vector3 position;
        Effect effect;

        public const int ShadowMapSize = 1024;
        
        /// <summary>
        /// Gets or sets the view matrix used to draw the shadow map
        /// </summary>
        public Matrix View
        {
            get { return view; }
            set { view = value; }
        }

        /// <summary>
        /// Gets or sets the projection matrix used to draw the shadow map
        /// </summary>
        public Matrix Projection
        {
            get { return projection; }
            set { projection = value; }
        }

        /// <summary>
        /// Gets the view projection matrix used to draw the shadow map
        /// </summary>
        public Matrix ViewProjection
        {
            get { return viewProjection; }
        }

        /// <summary>
        /// Gets or sets the light
        /// </summary>
        public Vector3 Position
        {
            get { return position; }
            set { position = value; }
        }

        /// <summary>
        /// Gets the texture generated by shadow mapping
        /// </summary>
        public Texture2D ShadowMap
        {
            get { return shadowMap; }
        }

        /// <summary>
        /// Gets the effect used to generate the shadow map
        /// </summary>
        public Effect Effect
        {
            get { return effect; }
        }

        #endregion

        #region Methods

        public ShadowMapEffect(BaseGame game)
        {
            this.game = game;
            graphics = game.GraphicsDevice;

            // Create textures
            renderTarget = new RenderTarget2D(
                graphics, ShadowMapSize, ShadowMapSize, 1, SurfaceFormat.Single);

            // Create a stencil buffer in case our screen is not large
            // enough to hold the render target.
            depthStencil = new DepthStencilBuffer(
                graphics, ShadowMapSize, ShadowMapSize,
                graphics.DepthStencilBuffer.Format);

            // Init effect
            effect = game.Content.Load<Effect>("Effects/ShadowMap");

            Log.Write("Shadow Mapping Initialized...");
        }

        /// <summary>
        /// Begins a shadow mapping generation process
        /// </summary>
        public void Begin()
        {
            // Store current stencil buffer
            storedDepthStencil = graphics.DepthStencilBuffer;

            // Set shadow mapping targets
            graphics.SetRenderTarget(0, renderTarget);
            graphics.DepthStencilBuffer = depthStencil;

            graphics.Clear(Color.White);

            // Initialize passes
            // Look at -z, world up is +y
            view = Matrix.CreateLookAt(
                position, position - Vector3.UnitZ, Vector3.UnitY);
            viewProjection = view * projection;
        }

        /// <summary>
        /// Ends shadow mapping generation and produce the generated shadow map
        /// </summary>
        public void End()
        {
            // Restore everything
            graphics.SetRenderTarget(0, null);
            graphics.DepthStencilBuffer = storedDepthStencil;

            // Resolve render target
            shadowMap = renderTarget.GetTexture();
        }

        #endregion
        
        #region Dispose

        /// <summary>
        /// Dispose
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Dispose
        /// </summary>
        /// <param name="disposing">Disposing</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (depthStencil != null)
                    depthStencil.Dispose();

                if (renderTarget != null)
                    renderTarget.Dispose();

                if (shadowMap != null)
                    shadowMap.Dispose();

                if (effect != null)
                    effect.Dispose();
            }
        }

        #endregion
    }
}
